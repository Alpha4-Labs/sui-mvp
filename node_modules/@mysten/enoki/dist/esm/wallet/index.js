var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var _events, _accounts, _name, _id, _icon, _flow, _provider, _clientId, _redirectUrl, _extraParams, _client, _windowFeatures, _signTransaction, _signAndExecuteTransaction, _signPersonalMessage, _on, _EnokiWallet_instances, setAccount_fn, _connect, _disconnect, validateChain_fn;
import { Transaction } from "@mysten/sui/transactions";
import { fromBase64, toBase64 } from "@mysten/sui/utils";
import { getWallets, ReadonlyWalletAccount } from "@mysten/wallet-standard";
import mitt from "mitt";
import { ENOKI_PROVIDER_WALLETS_INFO } from "./providers.js";
import { INTERNAL_ONLY_EnokiFlow } from "./state.js";
class EnokiWallet {
  constructor({
    name,
    icon,
    flow,
    provider,
    clientId,
    redirectUrl,
    extraParams,
    client,
    windowFeatures
  }) {
    __privateAdd(this, _EnokiWallet_instances);
    __privateAdd(this, _events);
    __privateAdd(this, _accounts);
    __privateAdd(this, _name);
    __privateAdd(this, _id);
    __privateAdd(this, _icon);
    __privateAdd(this, _flow);
    __privateAdd(this, _provider);
    __privateAdd(this, _clientId);
    __privateAdd(this, _redirectUrl);
    __privateAdd(this, _extraParams);
    __privateAdd(this, _client);
    __privateAdd(this, _windowFeatures);
    __privateAdd(this, _signTransaction, async ({ transaction, chain, account }) => {
      __privateMethod(this, _EnokiWallet_instances, validateChain_fn).call(this, chain);
      const parsedTransaction = Transaction.from(await transaction.toJSON());
      const keypair = await __privateGet(this, _flow).getKeypair();
      const suiAddress = keypair.toSuiAddress();
      if (suiAddress !== account.address) {
        throw new Error(
          `The specified account ${account.address} does not match the currently connected Enoki address ${suiAddress}.`
        );
      }
      parsedTransaction.setSenderIfNotSet(suiAddress);
      return keypair.signTransaction(await parsedTransaction.build({ client: __privateGet(this, _client) }));
    });
    __privateAdd(this, _signAndExecuteTransaction, async ({
      transaction,
      chain,
      account
    }) => {
      const { signature, bytes } = await __privateGet(this, _signTransaction).call(this, { transaction, account, chain });
      const { digest, rawEffects } = await __privateGet(this, _client).executeTransactionBlock({
        transactionBlock: bytes,
        signature,
        options: {
          showRawEffects: true
        }
      });
      return {
        digest,
        signature,
        bytes,
        effects: toBase64(Uint8Array.from(rawEffects))
      };
    });
    __privateAdd(this, _signPersonalMessage, async ({ message, account, chain }) => {
      __privateMethod(this, _EnokiWallet_instances, validateChain_fn).call(this, chain);
      const keypair = await __privateGet(this, _flow).getKeypair();
      const suiAddress = keypair.toSuiAddress();
      if (suiAddress !== account.address) {
        throw new Error(
          `The specified account ${account.address} does not match the currently connected Enoki address ${suiAddress}.`
        );
      }
      return keypair.signPersonalMessage(message);
    });
    __privateAdd(this, _on, (event, listener) => {
      __privateGet(this, _events).on(event, listener);
      return () => __privateGet(this, _events).off(event, listener);
    });
    __privateAdd(this, _connect, async (input) => {
      __privateMethod(this, _EnokiWallet_instances, setAccount_fn).call(this);
      if (this.accounts.length || input?.silent) {
        return { accounts: this.accounts };
      }
      const popup = window.open(
        void 0,
        "_blank",
        typeof __privateGet(this, _windowFeatures) === "function" ? __privateGet(this, _windowFeatures).call(this) : __privateGet(this, _windowFeatures)
      );
      if (!popup) {
        throw new Error("Failed to open popup");
      }
      const url = await __privateGet(this, _flow).createAuthorizationURL({
        provider: __privateGet(this, _provider),
        clientId: __privateGet(this, _clientId),
        redirectUrl: __privateGet(this, _redirectUrl) ?? window.location.href.split("#")[0],
        extraParams: __privateGet(this, _extraParams)
      });
      popup.location = url;
      await new Promise((resolve, reject) => {
        const interval = setInterval(() => {
          try {
            if (popup.closed) {
              clearInterval(interval);
              reject(new Error("Popup closed"));
            }
            if (!popup.location.hash) {
              return;
            }
          } catch (e) {
            return;
          }
          clearInterval(interval);
          __privateGet(this, _flow).handleAuthCallback(popup.location.hash).then(() => resolve(), reject);
          try {
            popup.close();
          } catch (e) {
            console.error(e);
          }
        }, 16);
      });
      __privateMethod(this, _EnokiWallet_instances, setAccount_fn).call(this);
      return { accounts: this.accounts };
    });
    __privateAdd(this, _disconnect, async () => {
      await __privateGet(this, _flow).logout();
      __privateMethod(this, _EnokiWallet_instances, setAccount_fn).call(this);
    });
    __privateSet(this, _accounts, []);
    __privateSet(this, _events, mitt());
    __privateSet(this, _client, client);
    __privateSet(this, _name, name);
    __privateSet(this, _id, `enoki:${provider}:${flow.network}:${clientId}`);
    __privateSet(this, _icon, icon);
    __privateSet(this, _flow, flow);
    __privateSet(this, _provider, provider);
    __privateSet(this, _clientId, clientId);
    __privateSet(this, _redirectUrl, redirectUrl);
    __privateSet(this, _extraParams, extraParams);
    __privateSet(this, _windowFeatures, windowFeatures);
    __privateMethod(this, _EnokiWallet_instances, setAccount_fn).call(this);
  }
  get id() {
    return __privateGet(this, _id);
  }
  get name() {
    return __privateGet(this, _name);
  }
  get provider() {
    return __privateGet(this, _provider);
  }
  get icon() {
    return __privateGet(this, _icon);
  }
  get version() {
    return "1.0.0";
  }
  get chains() {
    return [`sui:${__privateGet(this, _flow).network}`];
  }
  get accounts() {
    return __privateGet(this, _accounts);
  }
  get features() {
    return {
      "standard:connect": {
        version: "1.0.0",
        connect: __privateGet(this, _connect)
      },
      "standard:disconnect": {
        version: "1.0.0",
        disconnect: __privateGet(this, _disconnect)
      },
      "standard:events": {
        version: "1.0.0",
        on: __privateGet(this, _on)
      },
      "sui:signTransaction": {
        version: "2.0.0",
        signTransaction: __privateGet(this, _signTransaction)
      },
      "sui:signAndExecuteTransaction": {
        version: "2.0.0",
        signAndExecuteTransaction: __privateGet(this, _signAndExecuteTransaction)
      },
      "sui:signPersonalMessage": {
        version: "1.1.0",
        signPersonalMessage: __privateGet(this, _signPersonalMessage)
      }
    };
  }
}
_events = new WeakMap();
_accounts = new WeakMap();
_name = new WeakMap();
_id = new WeakMap();
_icon = new WeakMap();
_flow = new WeakMap();
_provider = new WeakMap();
_clientId = new WeakMap();
_redirectUrl = new WeakMap();
_extraParams = new WeakMap();
_client = new WeakMap();
_windowFeatures = new WeakMap();
_signTransaction = new WeakMap();
_signAndExecuteTransaction = new WeakMap();
_signPersonalMessage = new WeakMap();
_on = new WeakMap();
_EnokiWallet_instances = new WeakSet();
setAccount_fn = function() {
  const state = __privateGet(this, _flow).$zkLoginState.get();
  if (state.address && state.publicKey) {
    __privateSet(this, _accounts, [
      new ReadonlyWalletAccount({
        address: state.address,
        chains: this.chains,
        features: Object.keys(this.features),
        publicKey: fromBase64(state.publicKey)
      })
    ]);
  } else {
    __privateSet(this, _accounts, []);
  }
  __privateGet(this, _events).emit("change", { accounts: this.accounts });
};
_connect = new WeakMap();
_disconnect = new WeakMap();
validateChain_fn = function(chain) {
  if (!chain || !this.chains.includes(chain)) {
    throw new Error(
      `A valid Sui chain identifier was not provided in the request. Please report this issue to the dApp developer. Examples of valid Sui chain identifiers are 'sui:testnet' and 'sui:mainnet'. Consider using the '@mysten/dapp-kit' package, which provides this value automatically.`
    );
  }
};
function registerEnokiWallets({
  providers,
  client,
  network = "mainnet",
  windowFeatures = defaultWindowFeatures,
  ...config
}) {
  const walletsApi = getWallets();
  const flow = new INTERNAL_ONLY_EnokiFlow({ ...config, network });
  const unregisterCallbacks = [];
  const wallets = {};
  for (const { name, icon, provider } of ENOKI_PROVIDER_WALLETS_INFO) {
    const providerOptions = providers[provider];
    if (providerOptions) {
      const { clientId, redirectUrl, extraParams } = providerOptions;
      const wallet = new EnokiWallet({
        name,
        icon,
        flow,
        provider,
        clientId,
        client,
        redirectUrl,
        extraParams,
        windowFeatures
      });
      const unregister = walletsApi.register(wallet);
      unregisterCallbacks.push(unregister);
      wallets[provider] = wallet;
    }
  }
  return {
    wallets,
    unregister: () => {
      for (const unregister of unregisterCallbacks) {
        unregister();
      }
    }
  };
}
function isEnokiWallet(wallet) {
  return !!wallet.id?.startsWith("enoki:");
}
function defaultWindowFeatures() {
  const width = 500;
  const height = 800;
  const left = (screen.width - width) / 2;
  const top = (screen.height - height) / 4;
  return `popup=1;toolbar=0;status=0;resizable=1,width=${width},height=${height},top=${top},left=${left}`;
}
export {
  EnokiWallet,
  defaultWindowFeatures,
  isEnokiWallet,
  registerEnokiWallets
};
//# sourceMappingURL=index.js.map
