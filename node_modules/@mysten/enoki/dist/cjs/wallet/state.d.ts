import type { ZkLoginSignatureInputs } from '@mysten/sui/zklogin';
import type { WritableAtom } from 'nanostores';
import type { EnokiClientConfig } from '../EnokiClient/index.js';
import type { AuthProvider, EnokiNetwork } from '../EnokiClient/type.js';
import { EnokiKeypair } from '../EnokiKeypair.js';
type EnokiFlowConfig = EnokiClientConfig & {
    network: EnokiNetwork;
};
interface ZkLoginState {
    provider?: AuthProvider;
    address?: string;
    salt?: string;
    publicKey?: string;
}
interface ZkLoginSession {
    maxEpoch: number;
    randomness: string;
    expiresAt: number;
    jwt?: string;
    proof?: ZkLoginSignatureInputs;
}
export declare class INTERNAL_ONLY_EnokiFlow {
    #private;
    $zkLoginSession: WritableAtom<{
        initialized: boolean;
        value: ZkLoginSession | null;
    }>;
    $zkLoginState: WritableAtom<ZkLoginState>;
    constructor(config: EnokiFlowConfig);
    get network(): EnokiNetwork;
    createAuthorizationURL(input: {
        provider: AuthProvider;
        clientId: string;
        redirectUrl: string;
        extraParams?: Record<string, unknown>;
    }): Promise<string>;
    handleAuthCallback(hash?: string): Promise<string | null>;
    getSession(): Promise<ZkLoginSession | null>;
    logout(): Promise<void>;
    getProof(): Promise<import("../EnokiClient/type.js").CreateZkLoginZkpApiResponse>;
    getKeypair(): Promise<EnokiKeypair>;
}
export {};
