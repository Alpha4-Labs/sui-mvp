{
  "version": 3,
  "sources": ["../../../src/wallet/state.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { ExportedWebCryptoKeypair } from '@mysten/signers/webcrypto';\nimport { WebCryptoSigner } from '@mysten/signers/webcrypto';\nimport { decodeJwt } from '@mysten/sui/zklogin';\nimport type { ZkLoginSignatureInputs } from '@mysten/sui/zklogin';\nimport type { UseStore } from 'idb-keyval';\nimport { clear, createStore, get, set } from 'idb-keyval';\nimport type { WritableAtom } from 'nanostores';\nimport { atom, onMount, onSet } from 'nanostores';\n\nimport type { Encryption } from '../encryption.js';\nimport { createDefaultEncryption } from '../encryption.js';\nimport type { EnokiClientConfig } from '../EnokiClient/index.js';\nimport { EnokiClient } from '../EnokiClient/index.js';\nimport type { AuthProvider, EnokiNetwork } from '../EnokiClient/type.js';\nimport { EnokiKeypair } from '../EnokiKeypair.js';\nimport type { SyncStore } from '../stores.js';\nimport { createSessionStorage } from '../stores.js';\n\ntype EnokiFlowConfig = EnokiClientConfig & { network: EnokiNetwork };\n\n// State that is not bound to a session, and is encrypted.\ninterface ZkLoginState {\n\tprovider?: AuthProvider;\n\taddress?: string;\n\tsalt?: string;\n\tpublicKey?: string;\n}\n\n// State that session-bound, and is encrypted in storage.\ninterface ZkLoginSession {\n\tmaxEpoch: number;\n\trandomness: string;\n\texpiresAt: number;\n\n\tjwt?: string;\n\tproof?: ZkLoginSignatureInputs;\n}\n\nconst createStorageKeys = (apiKey: string, network: EnokiNetwork) => ({\n\tSTATE: `@enoki/flow/state/${apiKey}/${network}`,\n\tSESSION: `@enoki/flow/session/${apiKey}/${network}`,\n});\n\nexport class INTERNAL_ONLY_EnokiFlow {\n\t#storageKeys: { STATE: string; SESSION: string };\n\t#enokiClient: EnokiClient;\n\t#network: EnokiNetwork;\n\t#encryption: Encryption;\n\t#encryptionKey: string;\n\t#store: SyncStore;\n\t#idbStore: UseStore;\n\n\t$zkLoginSession: WritableAtom<{ initialized: boolean; value: ZkLoginSession | null }>;\n\t$zkLoginState: WritableAtom<ZkLoginState>;\n\n\tconstructor(config: EnokiFlowConfig) {\n\t\tthis.#enokiClient = new EnokiClient({\n\t\t\tapiKey: config.apiKey,\n\t\t\tapiUrl: config.apiUrl,\n\t\t});\n\t\tthis.#network = config.network;\n\t\tthis.#encryptionKey = config.apiKey;\n\t\tthis.#encryption = createDefaultEncryption();\n\t\tthis.#store = createSessionStorage();\n\t\tthis.#storageKeys = createStorageKeys(config.apiKey, this.#network);\n\t\tthis.#idbStore = createStore('enoki', `${config.apiKey}_${this.#network}`);\n\n\t\tlet storedState = null;\n\t\ttry {\n\t\t\tconst rawStoredValue = this.#store.get(this.#storageKeys.STATE);\n\t\t\tif (rawStoredValue) {\n\t\t\t\tstoredState = JSON.parse(rawStoredValue);\n\t\t\t}\n\t\t} catch {\n\t\t\t// Ignore errors\n\t\t}\n\n\t\tthis.$zkLoginState = atom(storedState || {});\n\t\tthis.$zkLoginSession = atom({ initialized: false, value: null });\n\n\t\t// Hydrate the session on mount:\n\t\tonMount(this.$zkLoginSession, () => {\n\t\t\tthis.getSession();\n\t\t});\n\n\t\tonSet(this.$zkLoginState, ({ newValue }) => {\n\t\t\tthis.#store.set(this.#storageKeys.STATE, JSON.stringify(newValue));\n\t\t});\n\t}\n\n\tget network() {\n\t\treturn this.#network;\n\t}\n\n\tasync createAuthorizationURL(input: {\n\t\tprovider: AuthProvider;\n\t\tclientId: string;\n\t\tredirectUrl: string;\n\t\textraParams?: Record<string, unknown>;\n\t}) {\n\t\tconst ephemeralKeyPair = await WebCryptoSigner.generate();\n\t\tconst { nonce, randomness, maxEpoch, estimatedExpiration } =\n\t\t\tawait this.#enokiClient.createZkLoginNonce({\n\t\t\t\tnetwork: this.#network,\n\t\t\t\tephemeralPublicKey: ephemeralKeyPair.getPublicKey(),\n\t\t\t});\n\n\t\tconst params = new URLSearchParams({\n\t\t\t...input.extraParams,\n\t\t\tnonce,\n\t\t\tclient_id: input.clientId,\n\t\t\tredirect_uri: input.redirectUrl,\n\t\t\tresponse_type: 'id_token',\n\t\t\t// TODO: Eventually fetch the scopes for this client ID from the Enoki service:\n\t\t\tscope: [\n\t\t\t\t'openid',\n\t\t\t\t// Merge the requested scopes in with the required openid scopes:\n\t\t\t\t...(input.extraParams && 'scope' in input.extraParams\n\t\t\t\t\t? (input.extraParams.scope as string[])\n\t\t\t\t\t: []),\n\t\t\t]\n\t\t\t\t.filter(Boolean)\n\t\t\t\t.join(' '),\n\t\t});\n\n\t\tlet oauthUrl: string;\n\t\tswitch (input.provider) {\n\t\t\tcase 'google': {\n\t\t\t\toauthUrl = `https://accounts.google.com/o/oauth2/v2/auth?${params}`;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'facebook': {\n\t\t\t\toauthUrl = `https://www.facebook.com/v17.0/dialog/oauth?${params}`;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'twitch': {\n\t\t\t\tparams.set('force_verify', 'true');\n\t\t\t\toauthUrl = `https://id.twitch.tv/oauth2/authorize?${params}`;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Invalid provider: ${input.provider}`);\n\t\t}\n\n\t\tthis.$zkLoginState.set({ provider: input.provider });\n\n\t\tawait set('ephemeralKeyPair', ephemeralKeyPair.export(), this.#idbStore);\n\t\tawait this.#setSession({\n\t\t\texpiresAt: estimatedExpiration,\n\t\t\tmaxEpoch,\n\t\t\trandomness,\n\t\t});\n\n\t\treturn oauthUrl;\n\t}\n\n\tasync handleAuthCallback(hash: string = window.location.hash) {\n\t\tconst params = new URLSearchParams(hash.startsWith('#') ? hash.slice(1) : hash);\n\n\t\t// Before we handle the auth redirect and get the state, we need to restore it:\n\t\tconst zkp = await this.getSession();\n\n\t\tif (!zkp || !zkp.maxEpoch || !zkp.randomness) {\n\t\t\tthrow new Error(\n\t\t\t\t'Start of sign-in flow could not be found. Ensure you have started the sign-in flow before calling this.',\n\t\t\t);\n\t\t}\n\n\t\tconst jwt = params.get('id_token');\n\t\tif (!jwt) {\n\t\t\tthrow new Error('Missing ID Token');\n\t\t}\n\n\t\tdecodeJwt(jwt);\n\n\t\tconst { address, salt, publicKey } = await this.#enokiClient.getZkLogin({ jwt });\n\n\t\tthis.$zkLoginState.set({\n\t\t\t...this.$zkLoginState.get(),\n\t\t\tsalt,\n\t\t\taddress,\n\t\t\tpublicKey,\n\t\t});\n\t\tawait this.#setSession({\n\t\t\t...zkp,\n\t\t\tjwt,\n\t\t});\n\n\t\treturn params.get('state');\n\t}\n\n\tasync #setSession(newValue: ZkLoginSession | null) {\n\t\tif (newValue) {\n\t\t\tconst storedValue = await this.#encryption.encrypt(\n\t\t\t\tthis.#encryptionKey,\n\t\t\t\tJSON.stringify(newValue),\n\t\t\t);\n\n\t\t\tthis.#store.set(this.#storageKeys.SESSION, storedValue);\n\t\t} else {\n\t\t\tthis.#store.delete(this.#storageKeys.SESSION);\n\t\t}\n\n\t\tthis.$zkLoginSession.set({ initialized: true, value: newValue });\n\t}\n\n\tasync getSession() {\n\t\tif (this.$zkLoginSession.get().initialized) {\n\t\t\treturn this.$zkLoginSession.get().value;\n\t\t}\n\n\t\ttry {\n\t\t\tconst storedValue = this.#store.get(this.#storageKeys.SESSION);\n\t\t\tif (!storedValue) return null;\n\n\t\t\tconst state: ZkLoginSession = JSON.parse(\n\t\t\t\tawait this.#encryption.decrypt(this.#encryptionKey, storedValue),\n\t\t\t);\n\n\t\t\t// TODO: Rather than having expiration act as a logout, we should keep the state that still is relevant,\n\t\t\t// and just clear out the expired session, but keep the other zkLogin state.\n\t\t\tif (state?.expiresAt && Date.now() > state.expiresAt) {\n\t\t\t\tawait this.logout();\n\t\t\t} else {\n\t\t\t\tthis.$zkLoginSession.set({ initialized: true, value: state });\n\t\t\t}\n\t\t} catch {\n\t\t\tthis.$zkLoginSession.set({ initialized: true, value: null });\n\t\t}\n\n\t\treturn this.$zkLoginSession.get().value;\n\t}\n\n\tasync logout() {\n\t\tthis.$zkLoginState.set({});\n\t\tthis.#store.delete(this.#storageKeys.STATE);\n\n\t\tawait clear(this.#idbStore);\n\t\tawait this.#setSession(null);\n\t}\n\n\t// TODO: Should this return the proof if it already exists?\n\tasync getProof() {\n\t\tconst zkp = await this.getSession();\n\t\tconst { salt } = this.$zkLoginState.get();\n\n\t\tif (zkp?.proof) {\n\t\t\tif (zkp.expiresAt && Date.now() > zkp.expiresAt) {\n\t\t\t\tthrow new Error('Stored proof is expired.');\n\t\t\t}\n\n\t\t\treturn zkp.proof;\n\t\t}\n\n\t\tif (!salt || !zkp || !zkp.jwt) {\n\t\t\tthrow new Error('Missing required parameters for proof generation');\n\t\t}\n\n\t\tconst storedNativeSigner = await get<ExportedWebCryptoKeypair>(\n\t\t\t'ephemeralKeyPair',\n\t\t\tthis.#idbStore,\n\t\t);\n\t\tif (!storedNativeSigner) {\n\t\t\tthrow new Error('Native signer not found in store.');\n\t\t}\n\n\t\tconst ephemeralKeyPair = WebCryptoSigner.import(storedNativeSigner);\n\n\t\tconst proof = await this.#enokiClient.createZkLoginZkp({\n\t\t\tnetwork: this.#network,\n\t\t\tjwt: zkp.jwt,\n\t\t\tmaxEpoch: zkp.maxEpoch,\n\t\t\trandomness: zkp.randomness,\n\t\t\tephemeralPublicKey: ephemeralKeyPair.getPublicKey(),\n\t\t});\n\n\t\tawait this.#setSession({\n\t\t\t...zkp,\n\t\t\tproof,\n\t\t});\n\n\t\treturn proof;\n\t}\n\n\tasync getKeypair() {\n\t\t// Get the proof, so that we ensure it exists in state:\n\t\tawait this.getProof();\n\n\t\tconst zkp = await this.getSession();\n\n\t\t// Check to see if we have the essentials for a keypair:\n\t\tconst { address } = this.$zkLoginState.get();\n\t\tif (!address || !zkp || !zkp.proof) {\n\t\t\tthrow new Error('Missing required data for keypair generation.');\n\t\t}\n\n\t\tif (Date.now() > zkp.expiresAt) {\n\t\t\tthrow new Error('Stored proof is expired.');\n\t\t}\n\n\t\tconst storedNativeSigner = await get<ExportedWebCryptoKeypair>(\n\t\t\t'ephemeralKeyPair',\n\t\t\tthis.#idbStore,\n\t\t);\n\n\t\tif (!storedNativeSigner) {\n\t\t\tthrow new Error('Native signer not found in store.');\n\t\t}\n\n\t\tconst ephemeralKeypair = WebCryptoSigner.import(storedNativeSigner);\n\n\t\treturn new EnokiKeypair({\n\t\t\taddress,\n\t\t\tephemeralKeypair,\n\t\t\tmaxEpoch: zkp.maxEpoch,\n\t\t\tproof: zkp.proof,\n\t\t});\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
